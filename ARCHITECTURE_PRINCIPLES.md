# Architecture Principles: Peer Server

**See `SERVER_ARCHITECTURE.md` for the distinction between Relay Tracker and Peer Server.**

This document describes the **Peer Server** philosophy—the HTTP file server running on each client.

## Core Philosophy

**Remote clients own their own rendering and behavior.** The Peer Server is a data provider, not a UI framework. Clients decide how to browse, search, and display files.

## Server Responsibilities

The HTTP file server is intentionally minimal and agnostic about client behavior:

### 1. Serve Files, Nothing More
- Stream requested files from the configured root directory
- Support multiple files via ephemeral ports or the existing connection
- Prevent directory traversal attacks
- Return appropriate HTTP status codes

### 2. Index Only What's Explicitly Requested
- Default `index.md` file contains only **markdown content**
- No automatic file indexing or discovery
- No search endpoints
- No filtering APIs
- No breadcrumb URLs

### 3. Client-Driven Navigation
- If a client decides not to link to certain files, those files won't be discovered by browsing
- Files must be accessed by typing in their path directly in the URL
- This is by design, not a limitation
- Allows servers to keep certain files private without hiding them

## What We Do NOT Include

### ❌ File Search/Filtering
- No search endpoint
- No filter APIs
- No file type enumeration
- Client can build these features if they want, but it's their responsibility

### ❌ Automatic Breadcrumb Navigation
- Breadcrumbs only appear if the client includes them in the served markdown/HTML files
- Navigation structure is determined by file content, not by the server
- Allows total control over what users can navigate to

### ❌ Server-Side Rendering Hints
- Server doesn't suggest "popular files"
- No metadata about file structure for rendering purposes
- No file previews or thumbnails generated by server
- All rendering decisions are client-side

## What We DO Include

### ✅ File Serving
```
GET /api/files
GET /content/*path
GET /download/*path
```

### ✅ Large File Support
- Stream large video files efficiently
- Support via:
  - Existing connection (chunked transfer encoding)
  - Ephemeral second port (dedicated large file stream)
- Client chooses which strategy to use

### ✅ Security
- Directory traversal prevention
- Localhost-only binding
- Proper error responses (404, 403, etc.)

### ✅ Basic File Metadata
- File name
- File type (directory vs file)
- File size
- Last modified timestamp

## Future: Automatic Indexing

Later, we may add:
- Automatic indexing of files (server generates an index)
- Index in a structured format (JSON, YAML)
- Client uses index for discovery if they choose

But **not yet**. Current phase focuses on basic file serving.

## Design Patterns

### 1. Files as the Source of Truth
```
Server provides raw files
         ↓
Client reads files
         ↓
Client interprets content
         ↓
Client renders UI based on content
```

### 2. Progressive Disclosure
```
User starts with index.md
         ↓
index.md contains links to other files
         ↓
User follows links to access files
         ↓
Each file may contain links to other files
```

### 3. URL as Full Address
```
/README.md                  → Top-level readme
/docs/guide.md              → Guide in docs folder
/docs/advanced/tutorial.md  → Tutorial in nested folder
```

No discovery needed—clients just navigate URLs directly.

## Client Responsibilities

Clients can build their own:
- File search/discovery UI
- Breadcrumb navigation (if included in served files)
- File filtering
- Sorting
- Organization
- Preview generation
- Thumbnail caching
- And any other browsing features

The server provides the data; clients provide the experience.

## Implementation Details

### HTTP Endpoints
```
GET /api/files                  List files in current directory
GET /api/files/docs             List files in subdirectory
GET /content/README.md          Get text file content
GET /download/image.png         Download/stream binary file
```

### Directory Traversal Protection
```
Canonical path resolution
Symlink escape detection
Verify final path within root directory
Return 403 Forbidden for unauthorized access
```

### Large File Streaming
Options:
1. **Single connection streaming** - Use chunked transfer encoding
2. **Ephemeral port** - Create dedicated port for large file, close after transfer

Client chooses strategy based on their needs.

### Default index.md
```markdown
# File Browser

Welcome to the Flashback relay file server.

This directory contains:
- [Documents](docs/)
- [Videos](videos/)
- [Resources](resources/)

Navigate by modifying the URL directly, or follow links in this file.
```

Simple, content-only markdown. No metadata. No structure hints.

## Why This Approach?

### Flexibility
Each remote client can implement browsing however they want.

### Security
Clients control what gets exposed. Servers don't dictate visibility.

### Minimal Server
Less code = fewer bugs = better reliability.

### Clear Separation of Concerns
- **Server**: Provides data
- **Client**: Decides what to do with it

### Scalability
No per-client state on server. No caching of client preferences. No session management for browsing.

## Example Client Implementations

### Client A: Simple File Viewer
```
Shows raw file lists from /api/files
No search
No filtering
Just click and view
```

### Client B: Full-Featured Browser
```
Uses /api/files endpoint
Implements local search/filter
Caches file listings
Shows breadcrumb navigation (from served files)
Generates thumbnails locally
```

### Client C: Document Navigator
```
Reads index.md
Follows links in index.md
Builds hierarchy from file content
Implements table of contents
```

All three clients can coexist using the same server, each implementing different UX.

## Testing

### Server Tests
- Files serve correctly
- Directory traversal blocked
- Large files stream without error
- Ephemeral ports work
- 404 for missing files
- 403 for unauthorized access

### Client Tests (in client's responsibility)
- Can read /api/files endpoint
- Can fetch content from /content
- Can handle large files
- Can navigate URLs directly
- Can implement search/filter/breadcrumbs as needed

## Conclusion

**The HTTP file server is a data provider, not a UI framework.** Remote clients are responsible for building the user experience they want. This keeps the server simple, secure, and flexible for diverse client implementations.
