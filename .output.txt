diff --git a/client/src-tauri/src/main.rs b/client/src-tauri/src/main.rs
index 9c6e93f..cdca2ab 100644
--- a/client/src-tauri/src/main.rs
+++ b/client/src-tauri/src/main.rs
@@ -80,181 +80,166 @@ struct AppState {

 #[tauri::command]
 async fn connect_to_server(
-    server_ip: String,
-    server_port: u16,
-    client_ip: String,
-    client_port: u16,
+    server: String,
     state: State<'_, AppState>,
     app_handle: tauri::AppHandle,
 ) -> Result<String, String> {
+    // Parse server:port
+    let (server_ip, server_port) = parse_host_port(&server)?;
     let addr = format!("{}:{}", server_ip, server_port);

-    // Save self info
+    // Detect local client IP
+    let client_ip = local_ip_address::local_ip()
+        .map_err(|e| format!("Failed to determine local IP: {}", e))?
+        .to_string();
+
+    // Start peer listener (accept incoming peer connections) on ephemeral port 0 and capture actual port
+    let listener = TcpListener::bind("0.0.0.0:0")
+        .await
+        .map_err(|e| format!("Failed to bind peer listener: {}", e))?;
+    let actual_port = listener
+        .local_addr()
+        .map_err(|e| format!("Failed to get listener local addr: {}", e))?
+        .port();
+
+    // Save self info with detected IP and actual bound port
     {
         let mut self_lock = state.self_info.lock().unwrap();
         *self_lock = Some(ClientInfo {
             ip: client_ip.clone(),
-            port: client_port,
+            port: actual_port,
         });
     }
-    // Start peer listener (accept incoming peer connections)
+    // Spawn the listener accept loop
     {
-        let listen_addr = format!("0.0.0.0:{}", client_port);
         let app_handle_clone = app_handle.clone();
+        let print_addr = format!("0.0.0.0:{}", actual_port);
         tokio::spawn(async move {
-            match TcpListener::bind(&listen_addr).await {
-                Ok(listener) => {
-                    println!("👂 Peer listener started at {}", listen_addr);
-                    loop {
-                        match listener.accept().await {
-                            Ok((mut stream, remote)) => {
-                                println!("🔗 Incoming peer connection from {}", remote);
-                                let app_handle_incoming = app_handle_clone.clone();
-                                // capture peer_writers map
-                                let pw_map = app_handle_clone.state::<AppState>().peer_writers.clone();
-                                tokio::spawn(async move {
-                                    let (reader, writer) = stream.into_split();
-                                    // keep an Arc to the writer so we can alias it under the correct peer key once we know from_ip/from_port
-                                    let writer_arc = Arc::new(tokio::sync::Mutex::new(writer));
-                                    let mut reader = BufReader::new(reader);
-                                    // register writer in map under the remote socket key (may be ephemeral)
-                                    let key = format!("{}", remote);
-                                    {
-                                        let mut map = pw_map.lock().unwrap();
-                                        map.insert(key.clone(), writer_arc.clone());
-                                    }
-                                    let mut line = String::new();
-                                    loop {
-                                        line.clear();
-                                        match reader.read_line(&mut line).await {
-                                            Ok(0) => break,
-                                            Ok(_) => {
-                                                if let Ok(msg) = serde_json::from_str::<Message>(&line) {
-                                                    match msg {
-                                                        Message::Ping => {
-                                                            // respond with Pong using stored writer
-                                                            let pong = serde_json::to_string(&Message::Pong).unwrap() + "\n";
-                                                            let writer_arc_opt = { pw_map.lock().unwrap().get(&key).cloned() };
-                                                            if let Some(w) = writer_arc_opt {
-                                                                if let Ok(mut guard) = w.try_lock() {
-                                                                    if let Err(
e) = guard.write_all(pong.as_bytes()).await { println!("Peer write error: {}", e); break; }
-                                                                    if let Err(e) = guard.flush().await { println!("Peer flush error: {}", e); break; }
-                                                                }
-                                                            }
-                                                        }
-                                                        Message::DccRequest { from_ip, from_port, .. } => {
-                                                            // Ensure writer is accessible under the canonical peer key
-                                                            {
-                                                                let alias = peer_key(&from_ip, from_port);
-                                                                let mut map = pw_map.lock().unwrap();
-                                                                if !map.contains_key(&alias) {
-                                                                    map.insert(alias.clone(), writer_arc.clone());
-                                                                }
-                                                            }
-                                                            let payload = serde_json::json!({"ip": from_ip, "port": from_port});
-                                                            let _ = app_handle_incoming.emit("dcc-request", payload);
-                                                        }
-                                                        Message::DccOpened { from_ip, from_port, .. } => {
-                                                            {
-                                                                let alias = peer_key(&from_ip, from_port);
-                                                                let mut map = pw_map.lock().unwrap();
-                                                                if !map.contains_key(&alias) {
-                                                                    map.insert(alias.clone(), writer_arc.clone());
-                                                                }
-                                                            }
-                                                            let payload = serde_json::json!({"ip": from_ip, "port": from_port});
-                                                            let _ = app_handle_incoming.emit("dcc-opened", payload);
-                                                        }
-                                                        Message::FileOffer { from_ip, from_port, name, size, .. } => {
-                                                            {
-                                                                let alias = peer_key(&from_ip, from_port);
-                                                                let mut map = pw_map.lock().unwrap();
-                                                                if !map.contains_key(&alias) {
-                                                                    map.insert(alias.clone(), writer_arc.clone());
-                                                                }
-                                                            }
-                                                            let payload = serde
_json::json!({"from_ip": from_ip, "from_port": from_port, "name": name, "size": size});
-                                                            let _ = app_handle_incoming.emit("dcc-file-offer", payload);
-                                                        }
-                                                        Message::FileAccept { from_ip, from_port, name, action, .. } => {
-                                                            {
-                                                                let alias = peer_key(&from_ip, from_port);
-                                                                let mut map = pw_map.lock().unwrap();
-                                                                if !map.contains_key(&alias) {
-                                                                    map.insert(alias.clone(), writer_arc.clone());
-                                                                }
-                                                            }
-                                                            let payload = serde
_json::json!({"from_ip": from_ip, "from_port": from_port, "name": name, "action": action});
-                                                            let _ = app_handle_incoming.emit("dcc-file-accept", payload);
-                                                        }
-                                                        Message::FileChunk { from_ip, from_port, name, offset, bytes_total, data_base64, .. } => {
-                                                            {
-                                                                let alias = peer_key(&from_ip, from_port);
-                                                                let mut map = pw_map.lock().unwrap();
-                                                                if !map.contains_key(&alias) {
-                                                                    map.insert(alias.clone(), writer_arc.clone());
-                                                                }
-                                                            }
-                                                            let payload = serde_json::json!({
-                                                                "from_ip": from_ip,
-                                                                "from_port": from_port,
-                                                                "name": name,
-                                                                "offset": offset,
-                                                                "bytes_total": bytes_total,
-                                                                "data_base64": data_base64,
-                                                            });
-                                                            let _ = app_handle_incoming.emit("dcc-file-chunk", payload);
-                                                        }
-                                                        Message::FileCancel { from_ip, from_port, name, .. } => {
-                                                            {
-                                                                let alias = peer_key(&from_ip, from_port);
-                                                                let mut map = pw_map.lock().unwrap();
-                                                                if !map.contains_key(&alias) {
-                                                                    map.insert(alias.clone(), writer_arc.clone());
-                                                                }
-                                                            }
-                                                            let payload = serde_json::json!({"from_ip": from_ip, "from_port": from_port, "name": name});
-                                                            let _ = app_handle_incoming.emit("dcc-file-cancel", payload);
-                                                        }
-                                                        Message::DccChat { from_ip, from_port, text, timestamp, .. } => {
-                                                            {
-                                                                let alias = peer_key(&from_ip, from_port);
-                                                                let mut map = pw_map.lock().unwrap();
-                                                                if !map.contains_key(&alias) {
-                                                                    map.insert(alias.clone(), writer_arc.clone());
-                                                                }
-                                                            }
-                                                            let payload = serde_json::json!({
-                                                                "from_ip": from_ip,
-                                                                "from_port": from_port,
-                                                                "text": text,
-                                                                "timestamp": timestamp,
-                                                            });
-                                                            let _ = app_handle_incoming.emit("dcc-chat", payload);
+            println!("👂 Peer listener started at {}", print_addr);
+            let pw_map = app_handle_clone.state::<AppState>().peer_writers.clone();
+            let app_handle_outer = app_handle_clone.clone();
+            let mut listener = listener; // move into task
+            loop {
+                match listener.accept().await {
+                    Ok((mut stream, remote)) => {
+                        println!("🔗 Incoming peer connection from {}", remote);
+                        let app_handle_incoming = app_handle_outer.clone();
+                        // capture peer_writers map
+                        let pw_map = pw_map.clone();
+                        tokio::spawn(async move {
+                            let (reader, writer) = stream.into_split();
+                            let writer_arc = Arc::new(tokio::sync::Mutex::new(writer));
+                            let mut reader = BufReader::new(reader);
+                            let key = format!("{}", remote);
+                            {
+                                let mut map = pw_map.lock().unwrap();
+                                map.insert(key.clone(), writer_arc.clone());
+                            }
+                            let mut line = String::new();
+                            loop {
+                                line.clear();
+                                match reader.read_line(&mut line).await {
+                                    Ok(0) => break,
+                                    Ok(_) => {
+                                        if let Ok(msg) = serde_json::from_str::<Message>(&line) {
+                                            match msg {
+                                                Message::Ping => {
+                                                    let pong = serde_json::to_string(&Message::Pong).unwrap() + "\n";
+                                                    let writer_arc_opt = { pw_map.lock().unwrap().get(&key).cloned() };
+                                                    if let Some(w) = writer_arc_opt {
+                                                        if let Ok(mut guard) = w.try_lock() {
+                                                            if let Err(e) = gua
rd.write_all(pong.as_bytes()).await { println!("Peer write error: {}", e); break; }
+                                                            if let Err(e) = guard.flush().await { println!("Peer flush error: {}", e); break; }
                                                         }
-                                                        _ => {}
                                                     }
                                                 }
-                                            }
-                                            Err(e) => {
-                                                println!("Peer read error: {}", e);
-                                                break;
+                                                Message::DccRequest { from_ip, from_port, .. } => {
+                                                    {
+                                                        let alias = peer_key(&from_ip, from_port);
+                                                        let mut map = pw_map.lock().unwrap();
+                                                        if !map.contains_key(&alias) { map.insert(alias.clone(), writer_arc.clone()); }
+                                                    }
+                                                    let payload = serde_json::json!({"ip": from_ip, "port": from_port});
+                                                    let _ = app_handle_incoming.emit("dcc-request", payload);
+                                                }
+                                                Message::DccOpened { from_ip, from_port, .. } => {
+                                                    {
+                                                        let alias = peer_key(&from_ip, from_port);
+                                                        let mut map = pw_map.lock().unwrap();
+                                                        if !map.contains_key(&alias) { map.insert(alias.clone(), writer_arc.clone()); }
+                                                    }
+                                                    let payload = serde_json::json!({"ip": from_ip, "port": from_port});
+                                                    let _ = app_handle_incoming.emit("dcc-opened", payload);
+                                                }
+                                                Message::FileOffer { from_ip, from_port, name, size, .. } => {
+                                                    {
+                                                        let alias = peer_key(&from_ip, from_port);
+                                                        let mut map = pw_map.lock().unwrap();
+                                                        if !map.contains_key(&alias) { map.insert(alias.clone(), writer_arc.clone()); }
+                                                    }
+                                                    let payload = serde_json::json!({"from_ip": from_ip, "from_port": from_port, "name": name, "size": size});
+                                                    let _ = app_handle_incoming.emit("dcc-file-offer", payload);
+                                                }
+                                                Message::FileAccept { from_ip, from_port, name, action, .. } => {
+                                                    {
+                                                        let alias = peer_key(&from_ip, from_port);
+                                                        let mut map = pw_map.lock().unwrap();
+                                                        if !map.contains_key(&alias) { map.insert(alias.clone(), writer_arc.clone()); }
+                                                    }
+                                                    let payload = serde_json::j
son!({"from_ip": from_ip, "from_port": from_port, "name": name, "action": action});
+                                                    let _ = app_handle_incoming.emit("dcc-file-accept", payload);
+                                                }
+                                                Message::FileChunk { from_ip, from_port, name, offset, bytes_total, data_base64, .. } => {
+                                                    {
+                                                        let alias = peer_key(&from_ip, from_port);
+                                                        let mut map = pw_map.lock().unwrap();
+                                                        if !map.contains_key(&alias) { map.insert(alias.clone(), writer_arc.clone()); }
+                                                    }
+                                                    let payload = serde_json::json!({
+                                                        "from_ip": from_ip,
+                                                        "from_port": from_port,
+                                                        "name": name,
+                                                        "offset": offset,
+                                                        "bytes_total": bytes_total,
+                                                        "data_base64": data_base64
+                                                    });
+                                                    let _ = app_handle_incoming.emit("dcc-file-chunk", payload);
+                                                }
+                                                Message::FileCancel { from_ip, from_port, name, .. } => {
+                                                    {
+                                                        let alias = peer_key(&from_ip, from_port);
+                                                        let mut map = pw_map.lock().unwrap();
+                                                        if !map.contains_key(&alias) { map.insert(alias.clone(), writer_arc.clone()); }
+                                                    }
+                                                    let payload = serde_json::json!({"from_ip": from_ip, "from_port": from_port, "name": name});
+                                                    let _ = app_handle_incoming.emit("dcc-file-cancel", payload);
+                                                }
+                                                Message::DccChat { from_ip, from_port, text, timestamp, .. } => {
+                                                    {
+                                                        let alias = peer_key(&from_ip, from_port);
+                                                        let mut map = pw_map.lock().unwrap();
+                                                        if !map.contains_key(&alias) { map.insert(alias.clone(), writer_arc.clone()); }
+                                                    }
+                                                    let payload = serde_json::json!({
+                                                        "from_ip": from_ip,
+                                                        "from_port": from_port,
+                                                        "text": text,
+                                                        "timestamp": timestamp,
+                                                    });
+                                                    let _ = app_handle_incoming.emit("dcc-chat", payload);
+                                                }
+                                                _ => {}
                                             }
                                         }
                                     }
-                                    let _ = app_handle_incoming.emit("peer-incoming-closed", format!("{}", remote));
-                                });
-                            }
-                            Err(e) => {
-                                println!("Listener accept error: {}", e);
-                                break;
+                                    Err(e) => { println!("Peer read error: {}", e); break; }
+                                }
                             }
-                        }
+                            let _ = app_handle_incoming.emit("peer-incoming-closed", format!("{}", remote));
+                        });
                     }
-                }
-                Err(e) => {
-                    println!("❌ Failed to bind peer listener {}: {}", listen_aaddr, e);
+                    Err(e) => { println!("Listener accept error: {}", e); break; }
                 }
             }
         });
@@ -272,10 +257,10 @@ async fn connect_to_server(
     let (reader, mut writer) = stream.into_split();
     let mut reader = BufReader::new(reader);
-    // Send registration message
+    // Send registration message with detected IP and bound port
     let register_msg = Message::Register {
         client_ip: client_ip.clone(),
-        client_port,
+        client_port: actual_port,
     };
     let json = serde_json::to_string(&register_msg).map_err(|e| e.to_string())? + "\n";
@@ -916,6 +901,7 @@ async fn send_chat_message(
 }
 fn main() {
+    // Build shared AppState used by both GUI and CLI modes
     let app_state = AppState {
         clients: Arc::new(Mutex::new(Vec::new())),
         tx: Arc::new(Mutex::new(None)),
@@ -925,6 +911,35 @@ fn main() {
         peer_writers: Arc::new(Mutex::new(HashMap::new())),
     };
+    let args: Vec<String> = std::env::args().collect();
+    if args.iter().any(|a| a == "--help" || a == "-h") {
+        print_cli_help();
+        return;
+    }
+    if args.iter().any(|a| a == "--cli") {
+        // CLI mode: Build a minimal Tauri App so we can reuse the same command functions and state
+        let app = tauri::Builder::default()
+            .manage(app_state)
+            .invoke_handler(tauri::generate_handler![
+                connect_to_server,
+                get_clients,
+                send_chat_message,
+                connect_to_peer,
+                peer_send_dcc_request,
+                peer_send_dcc_opened,
+                peer_send_file_offer,
+                peer_send_file_accept,
+                peer_send_file_chunk,
+                peer_send_file_cancel,
+                peer_send_dcc_chat
+            ])
+            .build(tauri::generate_context!())
+            .expect("failed to build tauri app for CLI mode");
+        run_cli(app);
+        return;
+    }
+
+    // GUI mode: Initialize Tauri builder and run the app
     tauri::Builder::default()
         .plugin(tauri_plugin_shell::init())
         .plugin(tauri_plugin_dialog::init())
@@ -948,6 +963,138 @@ fn main() {
         .expect("error while running tauri application");
 }
+fn print_cli_help() {
+    println!("Flashback Client CLI\n");
+    println!("Commands:");
+    println!("  --cli                 Start in interactive CLI mode");
+    println!("  --help, -h           Show this help");
+    println!("\nInteractive CLI commands:");
+    println!("  help                 Show this help");
+    println!("  connect-server <server:port>");
+    println!("                       Connect to the server (client IP is auto-detected; binds on a random local port)");
+    println!("  connect-peer <peer:port>");
+    println!("                       Connect to a peer client (DCC)");
+    println!("  send-channel <channel> <message>");
+    println!("                       Send a message to a server channel");
+    println!("  send-client <peer:port> <text>");
+    println!("                       Send a direct message to a peer client (DCC chat)");
+    println!("  quit | exit          Exit the CLI");
+}
+
+fn parse_host_port(input: &str) -> Result<(String, u16), String> {
+    let mut parts = input.rsplitn(2, ':');
+    let port_str = parts.next().ok_or_else(|| "missing port".to_string())?;
+    let host = parts.next().ok_or_else(|| "missing host".to_string())?;
+    let port: u16 = port_str.parse().map_err(|_| "invalid port".to_string())?;
+    if host.is_empty() { return Err("missing host".to_string()); }
+    Ok((host.to_string(), port))
+}
+
+
+fn run_cli(app: tauri::App) {
+    use std::io::{self, Write};
+    use tauri::async_runtime;
+
+    println!("Running in CLI mode! Type 'help' to see available commands.\n");
+    print_cli_help();
+
+    let app_handle = app.handle();
+    let state: tauri::State<AppState> = app_handle.state::<AppState>();
+
+    let mut line = String::new();
+    loop {
+        print!("> ");
+        let _ = io::stdout().flush();
+        line.clear();
+        if io::stdin().read_line(&mut line).is_err() {
+            println!("Failed to read input. Exiting.");
+            break;
+        }
+        let input = line.trim();
+        if input.is_empty() { continue; }
+        let mut parts = input.split_whitespace();
+        let cmd = parts.next().unwrap_or("");
+        match cmd {
+            "help" | "--help" | "-h" => {
+                print_cli_help();
+            }
+            "quit" | "exit" => {
+                println!("Bye!");
+                break;
+            }
+            "connect-server" => {
+                let server = match parts.next() { Some(s) => s.to_string(), None => { println!("Usage: connect-server <server:port>"); continue; } };
+                if parts.next().is_some() {
+                    println!("Warning: extra arguments ignored. Usage: connect-server <server:port>");
+                }
+                let ah = app_handle.clone();
+                let st = state.clone();
+                let fut = connect_to_server(server, st, ah);
+                match async_runtime::block_on(fut) {
+                    Ok(msg) => println!("{}", msg),
+                    Err(e) => println!("Error: {}", e),
+                }
+            }
+            "connect-peer" => {
+                let addr = match parts.next() { Some(s) => s.to_string(), None => { println!("Usage: connect-peer <peer:port>"); continue; } };
+                if let Ok((ip, port)) = parse_host_port(&addr) {
+                    let ah = app_handle.clone();
+                    let st = state.clone();
+                    let fut = connect_to_peer(ip, port, st, ah);
+                    match async_runtime::block_on(fut) {
+                        Ok(msg) => println!("{}", msg),
+                        Err(e) => println!("Error: {}", e),
+                    }
+                } else {
+                    println!("Usage: connect-peer <peer:port>");
+                }
+            }
+            "send-channel" => {
+                // message may contain spaces; reconstruct from remaining parts
+                let channel = match parts.next() { Some(c) => c.to_string(), None => { println!("Usage: send-channel <channel> <message>"); continue; } };
+                let message = parts.collect::<Vec<_>>().join(" ");
+                if message.is_empty() { println!("Usage: send-channel <channel> <message>"); continue; }
+                // try to pull client_ip/port from self_info
+                let (client_ip, client_port) = {
+                    let guard = state.self_info.lock().unwrap();
+                    if let Some(me) = &*guard {
+                        (me.ip.clone(), me.port)
+                    } else {
+                        println!("You must connect-server first to set your client_ip and client_port.");
+                        continue;
+                    }
+                };
+                let st = state.clone();
+                let fut = send_chat_message(message, channel, client_ip, client_port, st);
+                match async_runtime::block_on(fut) {
+                    Ok(msg) => println!("{}", msg),
+                    Err(e) => println!("Error: {}", e),
+                }
+            }
+            "send-client" => {
+                let addr = match parts.next() { Some(v) => v.to_string(), None => { println!("Usage: send-client <peer:port> <text>"); continue; } };
+                let text = parts.collect::<Vec<_>>().join(" ");
+                if text.is_empty() { println!("Usage: send-client <peer:port> <text>"); continue; }
+                match parse_host_port(&addr) {
+                    Ok((to_ip, to_port)) => {
+                        let st = state.clone();
+                        let fut = peer_send_dcc_chat(to_ip, to_port, text, st);
+                        match async_runtime::block_on(fut) {
+                            Ok(msg) => println!("{}", msg),
+                            Err(e) => println!("Error: {}", e),
+                        }
+                    }
+                    Err(_) => println!("Usage: send-client <peer:port> <text>"),
+                }
+            }
+            other => {
+                println!("Unknown command: {}", other);
+                println!("Type 'help' to see available commands.");
+            }
+        }
+    }
+}
+
 // Helper to emit the enriched client list using current peers map and self info
 fn emit_enriched_client_list(
     app_handle: &tauri::AppHandle,